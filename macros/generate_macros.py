import ConfigParser
import sys

controller = sys.argv[1]

infile = "{}.conf".format(controller)
cfile = "{}.c".format(controller)
hfile = "{}.h".format(controller)

template_c = """
inline void {}()
{{
{}
}}
"""

template_h = """inline void {}();
"""

command_format = "{}_{}"
bit_commands = {
	"0": "\t{} &= ~(1<<{});",
	"1": "\t{} |=  (1<<{});"
}

reserved_sections = set(("registers", "interrupts"))

class BadConfigException(BaseException):
	def __init__(self, msg):
		BaseException.__init__(self)
		self.msg = msg

	def __str__(self):
		return self.msg

config = ConfigParser.ConfigParser()
config.optionxform = str
with open(infile, "r") as f:
	config.readfp(f)

bit_registers = {}
for register in config.options("registers"):
	bit_names = [str.strip(bn) for bn in config.get("registers", register).split(" ")]
	if len(bit_names) != 8:
		raise BadConfigException("register {} has {} bits".format(register, len(bit_names)))
	for bit_name in bit_names:
		if bit_name == "-":
			continue
		if bit_name in bit_registers:
			raise BadConfigException("bit {} redefined for register {} - previous definition in register {}".format(bit_name, register, bit_registers[bit_name]))
		bit_registers[bit_name] = register

with open(cfile, "w") as c:
	with open(hfile, "w") as h:
		c.write("// This file was autogenerated from {}. Do not edit manually!\n".format(infile))
		h.write("// This file was autogenerated from {}. Do not edit manually!\n".format(infile))
		h.write("#define SET_BIT_0(name) name ## _reg &= ~(1<<name)\n")
		h.write("#define SET_BIT_1(name) name ## _reg |= (1<<name)\n")

		h.write("// registers for all used bit names\n")
		for bit, register in bit_registers.iteritems():
			h.write("#define {}_reg {}\n".format(bit, register))

		for section in config.sections():
			if section in reserved_sections:
				continue

			c.write("\n// {}\n".format(section))
			h.write("// {}\n".format(section))

			bit_names = config.get(section, "bits").split(" ")
			try:
				registers_for_this_section = [bit_registers[bit_name] for bit_name in bit_names]
			except KeyError as e:
				raise BadConfigException("Bit name {} undefined".format(e))

			options = config.options(section)
			if len(options) != len(set(options)): # check if all keys are unique
				raise BadConfigException("Multiple definitions in {}".format(section))

			if len(options) != 2**len(bit_names)+1:
				raise BadConfigException("section {} has {} definitions ({} expected)".format(section, len(options)-1, 2**len(bit_names)))

			for bits, name in config.items(section):
				if bits == "bits":
					continue
				if name == "-":
					continue

				assert len(bits) == len(bit_names)
				for bit in bits:
					assert bit in ("0", "1")

				commands = []
				for i, bit_value in enumerate(bits):
					register = registers_for_this_section[i]
					commands.append(bit_commands[bit_value].format(register, bit_names[i]))

				c.write(template_c.format(command_format.format(section, name), "\n".join(commands)))
				h.write(template_h.format(command_format.format(section, name)))

		# interrupts
		c.write("\n// interrupts\n\n")
		h.write("// interrupts\n")
		for name, bit_name in config.items("interrupts"):
			for enable_disable, bitvalue in (("enable", "1"), ("disable", "0")):
				c.write(template_c.format(command_format.format("int_"+name, enable_disable), bit_commands[bitvalue].format(bit_registers[bit_name], bit_name)))
				h.write(template_h.format(command_format.format("int_"+name, enable_disable)))
